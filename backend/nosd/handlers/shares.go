package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"path/filepath"

	"nithronos/backend/nosd/internal/config"
	"nithronos/backend/nosd/internal/shares"
	"nithronos/backend/nosd/pkg/agentclient"
	"nithronos/backend/nosd/pkg/httpx"
	poolroots "nithronos/backend/nosd/pkg/pools"
	sharetpl "nithronos/backend/nosd/pkg/shares"
	"nithronos/backend/nosd/pkg/validate"
)

type AgentPoster interface {
	PostJSON(ctx context.Context, path string, body any, v any) error
}

var AgentClientFactory = func() AgentPoster { return agentclient.New("/run/nos-agent.sock") }

// HandleCreateShare implements POST /api/shares
func HandleCreateShare(cfg config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var body shares.Share
		_ = json.NewDecoder(r.Body).Decode(&body)

		// type
		if body.Type != "smb" && body.Type != "nfs" {
			httpx.WriteError(w, http.StatusBadRequest, "type must be smb or nfs")
			return
		}
		// name
		if err := validate.ShareName(body.Name); err != nil {
			httpx.WriteError(w, http.StatusBadRequest, "invalid name; use 1-32 characters [A-Za-z0-9_-]")
			return
		}
		// allowed roots
		roots, err := poolroots.AllowedRoots()
		if err != nil {
			httpx.WriteError(w, http.StatusInternalServerError, err.Error())
			return
		}
		if err := validate.PathUnder(roots, body.Path); err != nil {
			httpx.WriteError(w, http.StatusBadRequest, "path not under allowed roots")
			return
		}
		clean := filepath.Clean(body.Path)

		st := shares.NewStore(cfg.SharesPath)
		// duplicates
		for _, ex := range st.List() {
			if ex.Name == body.Name {
				httpx.WriteError(w, http.StatusConflict, "share name already exists")
				return
			}
			if filepath.Clean(ex.Path) == clean {
				httpx.WriteError(w, http.StatusConflict, "path already shared")
				return
			}
		}

		// ensure directory exists via agent
		client := AgentClientFactory()
		var fsResp map[string]any
		if err := client.PostJSON(r.Context(), "/v1/fs/mkdir", map[string]any{
			"path":  clean,
			"mode":  "0775",
			"owner": "nos",
			"group": "nos",
		}, &fsResp); err != nil {
			httpx.WriteError(w, http.StatusInternalServerError, err.Error())
			return
		}

		// write config via agent
		switch body.Type {
		case "smb":
			frag, err := sharetpl.SmbFragment(body.Name, clean, body.RO, body.Users)
			if err != nil {
				httpx.WriteError(w, http.StatusBadRequest, err.Error())
				return
			}
			dest := filepath.Join(cfg.EtcDir, "samba", "smb.conf.d", fmt.Sprintf("nos-%s.conf", body.Name))
			var wrResp map[string]any
			if err := client.PostJSON(r.Context(), "/v1/fs/write", map[string]any{"path": dest, "content": frag, "mode": "0644", "owner": "root", "group": "root"}, &wrResp); err != nil {
				httpx.WriteError(w, http.StatusInternalServerError, err.Error())
				return
			}
			// ensure include (best-effort)
			inc := filepath.Join(cfg.EtcDir, "samba", "smb.conf.d", "00-nithron-include.conf")
			incContent := "# Generated by NithronOS â€” DO NOT EDIT\ninclude = /etc/samba/smb.conf.d/*.conf\n"
			_ = client.PostJSON(r.Context(), "/v1/fs/write", map[string]any{"path": inc, "content": incContent, "mode": "0644", "owner": "root", "group": "root"}, nil)
		case "nfs":
			line, err := sharetpl.NfsLine(clean, body.RO)
			if err != nil {
				httpx.WriteError(w, http.StatusBadRequest, err.Error())
				return
			}
			dest := filepath.Join(cfg.EtcDir, "exports.d", fmt.Sprintf("nos-%s.exports", body.Name))
			var wrResp map[string]any
			if err := client.PostJSON(r.Context(), "/v1/fs/write", map[string]any{"path": dest, "content": line + "\n", "mode": "0644", "owner": "root", "group": "root"}, &wrResp); err != nil {
				httpx.WriteError(w, http.StatusInternalServerError, err.Error())
				return
			}
		}

		// persist
		if body.ID == "" {
			body.ID = body.Name
		}
		_ = st.Add(body)

		// reload
		switch body.Type {
		case "smb":
			_ = client.PostJSON(r.Context(), "/v1/service/reload", map[string]any{"name": "smb"}, nil)
		case "nfs":
			_ = client.PostJSON(r.Context(), "/v1/service/reload", map[string]any{"name": "nfs"}, nil)
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		_ = json.NewEncoder(w).Encode(body)
	}

}
