#!/usr/bin/python3
# NithronOS Privileged Agent - Handles system configuration with root privileges

import socket
import os
import json
import sys
import subprocess
import threading
import logging
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[nos-agent] %(levelname)s: %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger('nos-agent')

SOCKET_PATH = '/run/nos-agent.sock'

class SystemConfigAgent:
    def __init__(self):
        self.socket_path = SOCKET_PATH
        
    def execute_command(self, cmd, shell=False):
        """Execute a system command and return result"""
        try:
            if shell:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            else:
                result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0, result.stdout, result.stderr
        except Exception as e:
            return False, "", str(e)
    
    def set_hostname(self, hostname):
        """Set system hostname"""
        try:
            # Set hostname immediately
            success, _, _ = self.execute_command(['hostnamectl', 'set-hostname', hostname])
            if not success:
                # Fallback method
                with open('/etc/hostname', 'w') as f:
                    f.write(hostname + '\n')
                self.execute_command(['hostname', hostname])
            
            # Update /etc/hosts
            with open('/etc/hosts', 'r') as f:
                lines = f.readlines()
            
            with open('/etc/hosts', 'w') as f:
                for line in lines:
                    if '127.0.1.1' in line:
                        f.write(f"127.0.1.1\t{hostname}\n")
                    else:
                        f.write(line)
            
            logger.info(f"Hostname set to: {hostname}")
            return True
        except Exception as e:
            logger.error(f"Failed to set hostname: {e}")
            return False
    
    def set_timezone(self, timezone):
        """Set system timezone"""
        try:
            # Verify timezone exists
            tz_path = f"/usr/share/zoneinfo/{timezone}"
            if not os.path.exists(tz_path):
                logger.error(f"Invalid timezone: {timezone}")
                return False
            
            # Set timezone using timedatectl
            success, _, _ = self.execute_command(['timedatectl', 'set-timezone', timezone])
            if not success:
                # Fallback method
                os.remove('/etc/localtime')
                os.symlink(tz_path, '/etc/localtime')
                with open('/etc/timezone', 'w') as f:
                    f.write(timezone + '\n')
            
            logger.info(f"Timezone set to: {timezone}")
            return True
        except Exception as e:
            logger.error(f"Failed to set timezone: {e}")
            return False
    
    def configure_ntp(self, enabled, servers=None):
        """Configure NTP"""
        try:
            if enabled:
                # Enable and start systemd-timesyncd
                self.execute_command(['systemctl', 'enable', 'systemd-timesyncd'])
                
                # Configure NTP servers if provided
                if servers:
                    config = "[Time]\n"
                    config += f"NTP={' '.join(servers)}\n"
                    Path('/etc/systemd/timesyncd.conf.d').mkdir(exist_ok=True)
                    with open('/etc/systemd/timesyncd.conf.d/nithronos.conf', 'w') as f:
                        f.write(config)
                
                self.execute_command(['systemctl', 'restart', 'systemd-timesyncd'])
                # Enable NTP synchronization
                self.execute_command(['timedatectl', 'set-ntp', 'true'])
            else:
                self.execute_command(['timedatectl', 'set-ntp', 'false'])
                self.execute_command(['systemctl', 'stop', 'systemd-timesyncd'])
            
            logger.info(f"NTP configured: enabled={enabled}")
            return True
        except Exception as e:
            logger.error(f"Failed to configure NTP: {e}")
            return False
    
    def configure_network(self, interface, config):
        """Configure network interface"""
        try:
            # This is a simplified implementation
            # In production, you'd use netplan or systemd-networkd
            logger.info(f"Network configuration for {interface}: {config}")
            return True
        except Exception as e:
            logger.error(f"Failed to configure network: {e}")
            return False
    
    def handle_request(self, data):
        """Handle incoming request and execute action"""
        try:
            request = json.loads(data)
            action = request.get('Action', '')
            params = request.get('Params', {})
            
            logger.info(f"Handling action: {action}")
            
            # Route to appropriate handler
            if action == 'system.hostname.set':
                hostname = params.get('hostname', '')
                if hostname:
                    success = self.set_hostname(hostname)
                    return {'status': 'ok' if success else 'error', 'result': 'success' if success else 'failed'}
            
            elif action == 'system.timezone.set':
                timezone = params.get('timezone', '')
                if timezone:
                    success = self.set_timezone(timezone)
                    return {'status': 'ok' if success else 'error', 'result': 'success' if success else 'failed'}
            
            elif action == 'system.ntp.set':
                enabled = params.get('enabled', True)
                servers = params.get('servers', [])
                success = self.configure_ntp(enabled, servers)
                return {'status': 'ok' if success else 'error', 'result': 'success' if success else 'failed'}
            
            elif action == 'system.network.configure':
                interface = params.get('interface', '')
                config = params.get('config', {})
                success = self.configure_network(interface, config)
                return {'status': 'ok' if success else 'error', 'result': 'success' if success else 'failed'}
            
            else:
                logger.warning(f"Unknown action: {action}")
                return {'status': 'ok', 'result': 'unknown_action'}
                
        except json.JSONDecodeError:
            logger.error("Invalid JSON in request")
            return {'status': 'error', 'error': 'invalid_json'}
        except Exception as e:
            logger.error(f"Error handling request: {e}")
            return {'status': 'error', 'error': str(e)}
    
    def parse_http_request(self, data):
        """Parse HTTP request to extract body"""
        try:
            lines = data.decode('utf-8', errors='ignore').split('\r\n')
            
            # Find empty line that separates headers from body
            body_start = -1
            for i, line in enumerate(lines):
                if line == '':
                    body_start = i + 1
                    break
            
            if body_start > 0 and body_start < len(lines):
                body = '\r\n'.join(lines[body_start:])
                return body
            return None
        except Exception as e:
            logger.error(f"Error parsing HTTP request: {e}")
            return None
    
    def create_http_response(self, status_code, body):
        """Create HTTP response"""
        body_str = json.dumps(body)
        response = f"HTTP/1.1 {status_code} OK\r\n"
        response += "Content-Type: application/json\r\n"
        response += f"Content-Length: {len(body_str)}\r\n"
        response += "\r\n"
        response += body_str
        return response.encode('utf-8')
    
    def handle_connection(self, conn):
        """Handle a client connection"""
        try:
            data = conn.recv(4096)
            if not data:
                return
            
            # Parse HTTP request to get body
            body = self.parse_http_request(data)
            
            if body:
                # Handle the request
                result = self.handle_request(body)
                response = self.create_http_response(200, result)
            else:
                # No body, return simple OK
                response = self.create_http_response(200, {'status': 'ok'})
            
            conn.send(response)
        except Exception as e:
            logger.error(f"Error handling connection: {e}")
            error_response = self.create_http_response(500, {'status': 'error', 'error': str(e)})
            try:
                conn.send(error_response)
            except:
                pass
        finally:
            conn.close()
    
    def run(self):
        """Main server loop"""
        # Clean up old socket
        if os.path.exists(self.socket_path):
            os.unlink(self.socket_path)
        
        # Create Unix socket
        server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server.bind(self.socket_path)
        
        # Make socket accessible
        os.chmod(self.socket_path, 0o666)
        
        server.listen(5)
        logger.info(f"Agent listening on {self.socket_path}")
        
        try:
            while True:
                conn, addr = server.accept()
                # Handle each connection in a thread
                thread = threading.Thread(target=self.handle_connection, args=(conn,))
                thread.daemon = True
                thread.start()
        except KeyboardInterrupt:
            logger.info("Shutting down...")
        except Exception as e:
            logger.error(f"Server error: {e}")
        finally:
            server.close()
            if os.path.exists(self.socket_path):
                os.unlink(self.socket_path)

if __name__ == '__main__':
    agent = SystemConfigAgent()
    agent.run()